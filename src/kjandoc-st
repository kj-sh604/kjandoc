#!/usr/bin/env python3

import os
import sys
import shutil
import subprocess
import tempfile
import uuid
import zipfile
from pathlib import Path
from lxml import etree


NS = {
    'office':       'urn:oasis:names:tc:opendocument:xmlns:office:1.0',
    'draw':         'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0',
    'style':        'urn:oasis:names:tc:opendocument:xmlns:style:1.0',
    'presentation': 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0',
    'text':         'urn:oasis:names:tc:opendocument:xmlns:text:1.0',
    'table':        'urn:oasis:names:tc:opendocument:xmlns:table:1.0',
    'xlink':        'http://www.w3.org/1999/xlink',
    'manifest':     'urn:oasis:names:tc:opendocument:xmlns:manifest:1.0',
}


def _ns(prefix, local):
    """expand namespace prefix to clark notation."""
    return f'{{{NS[prefix]}}}{local}'


# attributes that can reference auto-style names in odp content
STYLE_REF_ATTRS = [
    _ns('draw', 'style-name'),
    _ns('draw', 'text-style-name'),
    _ns('presentation', 'style-name'),
    _ns('text', 'style-name'),
    _ns('table', 'style-name'),
    _ns('style', 'parent-style-name'),
    _ns('style', 'list-style-name'),
    _ns('style', 'data-style-name'),
]

# declaration use-* attributes on draw:page elements
DECL_USE_ATTRS = [
    _ns('presentation', 'use-header-name'),
    _ns('presentation', 'use-footer-name'),
    _ns('presentation', 'use-date-time-name'),
]

# declaration element tags
DECL_TAGS = [
    _ns('presentation', 'header-decl'),
    _ns('presentation', 'footer-decl'),
    _ns('presentation', 'date-time-decl'),
]

# extension -> mime type for manifest entries
EXT_TO_MIME = {
    '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg',
    '.gif': 'image/gif', '.svg': 'image/svg+xml', '.svgz': 'image/svg+xml',
    '.wmf': 'image/x-wmf', '.emf': 'image/x-emf',
    '.bmp': 'image/bmp', '.tif': 'image/tiff', '.tiff': 'image/tiff',
}


# helpers
def _restyle(elem, style_map):
    """recursively update style-name references in an element tree."""
    for e in elem.iter():
        for attr in STYLE_REF_ATTRS:
            val = e.get(attr)
            if val and val in style_map:
                e.set(attr, style_map[val])


def _remap_hrefs(elem, href_map):
    """update xlink:href references for remapped media files."""
    attr = _ns('xlink', 'href')
    for e in elem.iter():
        val = e.get(attr)
        if val and val in href_map:
            e.set(attr, href_map[val])


def _remap_decls(page, decl_map):
    """update declaration use-* references on a draw:page."""
    for attr in DECL_USE_ATTRS:
        val = page.get(attr)
        if val and val in decl_map:
            page.set(attr, decl_map[val])


def _lo_convert(input_path, fmt, outdir):
    """convert a file via libreoffice --headless."""
    subprocess.run([
        'libreoffice', '--headless', '--convert-to', fmt,
        '--outdir', outdir, os.path.abspath(input_path)
    ], check=True, capture_output=True)

    for f in os.listdir(outdir):
        if f.lower().endswith(f'.{fmt}'):
            return os.path.join(outdir, f)
    raise RuntimeError(f"libreoffice failed to convert {input_path} to {fmt}")


def _repack_odp(directory, output_path):
    """zip a directory back into a valid odp file.
    mimetype entry must be first and stored uncompressed (odf spec)."""
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zf:
        mimetype = os.path.join(directory, 'mimetype')
        if os.path.exists(mimetype):
            zf.write(mimetype, 'mimetype', compress_type=zipfile.ZIP_STORED)

        for root, dirs, files in os.walk(directory):
            dirs.sort()
            for f in sorted(files):
                full = os.path.join(root, f)
                arcname = os.path.relpath(full, directory)
                if arcname == 'mimetype':
                    continue
                zf.write(full, arcname)


# core: concatenate odp files

def _concat_odps(odp_paths, output_odp):
    """concatenate slides from multiple odp files into one.
    assumes all presentations share the same template/master pages."""
    work_dir = tempfile.mkdtemp(prefix='kjandoc_st_')

    try:
        # extract base odp
        base_dir = os.path.join(work_dir, 'base')
        with zipfile.ZipFile(odp_paths[0], 'r') as z:
            z.extractall(base_dir)

        # parse base content.xml
        content_xml = os.path.join(base_dir, 'content.xml')
        content_tree = etree.parse(content_xml)
        croot = content_tree.getroot()

        auto_styles = croot.find(_ns('office', 'automatic-styles'))
        body = croot.find(_ns('office', 'body'))
        pres = body.find(_ns('office', 'presentation'))

        # parse manifest
        manifest_xml = os.path.join(base_dir, 'META-INF', 'manifest.xml')
        manifest_tree = etree.parse(manifest_xml)
        manifest_root = manifest_tree.getroot()

        base_pages = pres.findall(_ns('draw', 'page'))
        print(f"  -> base: {len(base_pages)} slides")

        # process each additional odp
        for idx, odp_path in enumerate(odp_paths[1:], start=2):
            prefix = f'_s{idx}_'
            label = Path(odp_path).stem

            add_dir = os.path.join(work_dir, f'add_{idx}')
            with zipfile.ZipFile(odp_path, 'r') as z:
                z.extractall(add_dir)

            add_tree = etree.parse(os.path.join(add_dir, 'content.xml'))
            add_root = add_tree.getroot()
            add_auto = add_root.find(_ns('office', 'automatic-styles'))
            add_body = add_root.find(_ns('office', 'body'))
            add_pres = add_body.find(_ns('office', 'presentation'))

            # auto-style rename map (first pass â€” collect all names)

            style_map = {}
            for s in add_auto:
                old_name = s.get(_ns('style', 'name'))
                if old_name:
                    style_map[old_name] = prefix + old_name

            # rename and append auto-styles (second pass)
            for s in list(add_auto):
                old_name = s.get(_ns('style', 'name'))
                if old_name and old_name in style_map:
                    s.set(_ns('style', 'name'), style_map[old_name])
                _restyle(s, style_map)
                auto_styles.append(s)

            # copy media (Pictures/) with unique names

            href_map = {}
            add_pics = os.path.join(add_dir, 'Pictures')
            base_pics = os.path.join(base_dir, 'Pictures')
            os.makedirs(base_pics, exist_ok=True)

            if os.path.isdir(add_pics):
                for mf in os.listdir(add_pics):
                    ext = Path(mf).suffix
                    uid = uuid.uuid4().hex[:8]
                    new_name = f'{prefix}{uid}{ext}'
                    shutil.copy2(
                        os.path.join(add_pics, mf),
                        os.path.join(base_pics, new_name)
                    )
                    href_map[f'Pictures/{mf}'] = f'Pictures/{new_name}'

                    # manifest entry
                    fe = etree.SubElement(manifest_root, _ns('manifest', 'file-entry'))
                    fe.set(_ns('manifest', 'full-path'), f'Pictures/{new_name}')
                    fe.set(
                        _ns('manifest', 'media-type'),
                        EXT_TO_MIME.get(ext.lower(), 'application/octet-stream')
                    )

            # copy header/footer/datetime declarations

            decl_map = {}
            decl_name_attr = _ns('presentation', 'name')

            # find insertion point: just before the first draw:page
            first_page = pres.find(_ns('draw', 'page'))
            insert_idx = list(pres).index(first_page) if first_page is not None else len(pres)

            for tag in DECL_TAGS:
                for decl in add_pres.findall(tag):
                    old_name = decl.get(decl_name_attr)
                    if old_name:
                        new_name = prefix + old_name
                        decl_map[old_name] = new_name
                        decl.set(decl_name_attr, new_name)
                    pres.insert(insert_idx, decl)
                    insert_idx += 1

            # append slides

            page_count = 0
            for page in list(add_pres.findall(_ns('draw', 'page'))):
                # rename page to avoid name collisions
                old_page_name = page.get(_ns('draw', 'name'))
                if old_page_name:
                    page.set(_ns('draw', 'name'), prefix + old_page_name)

                _restyle(page, style_map)
                _remap_hrefs(page, href_map)
                _remap_decls(page, decl_map)
                pres.append(page)
                page_count += 1

            print(f"  -> {label}: {page_count} slides appended")

        # write out modified xml
        content_tree.write(content_xml, xml_declaration=True, encoding='UTF-8')
        manifest_tree.write(manifest_xml, xml_declaration=True, encoding='UTF-8')

        # repack as odp
        _repack_odp(base_dir, output_odp)

    finally:
        shutil.rmtree(work_dir, ignore_errors=True)

    return output_odp


# main entry point

def concatenate_presentations(*pptx_files, output='concatenated.pptx'):
    """concatenate pptx files via odp round-trip. preserves full editability."""
    if not pptx_files:
        raise ValueError("no files provided")

    work_dir = tempfile.mkdtemp(prefix='kjandoc_st_main_')

    try:
        # step 1: pptx -> odp (libreoffice native format, lossless)
        odp_paths = []
        for pf in pptx_files:
            label = Path(pf).stem
            print(f"[*] converting to odp: {label}")
            conv_dir = os.path.join(work_dir, f'conv_{label}_{uuid.uuid4().hex[:6]}')
            os.makedirs(conv_dir)
            odp = _lo_convert(pf, 'odp', conv_dir)
            odp_paths.append(odp)

        # step 2: concatenate at odp xml level
        print(f"[*] concatenating slides...")
        combined_odp = os.path.join(work_dir, 'combined.odp')
        _concat_odps(odp_paths, combined_odp)

        # step 3: odp -> pptx (libreoffice produces clean editable pptx)
        print(f"[*] converting to pptx...")
        final_dir = os.path.join(work_dir, 'final')
        os.makedirs(final_dir)
        result_pptx = _lo_convert(combined_odp, 'pptx', final_dir)
        shutil.copy2(result_pptx, output)

        print(f"[+] concatenated -> {output}")

    finally:
        shutil.rmtree(work_dir, ignore_errors=True)

    return output


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description='concatenate pptx files sharing the same template (preserves editability)',
        usage='%(prog)s input1.pptx [input2.pptx ...] -o output.pptx'
    )
    parser.add_argument(
        'inputs',
        metavar='INPUT',
        nargs='+',
        help='input pptx files to concatenate (must share the same template)'
    )
    parser.add_argument(
        '-o', '--output',
        default='concatenated.pptx',
        help='output filename (default: concatenated.pptx)'
    )

    args = parser.parse_args()

    # validate input files
    for f in args.inputs:
        if not os.path.exists(f):
            print(f"[!] error: file not found: {f}", file=sys.stderr)
            sys.exit(1)
        if not f.lower().endswith('.pptx'):
            print(f"[!] error: not a pptx file: {f}", file=sys.stderr)
            sys.exit(1)

    concatenate_presentations(*args.inputs, output=args.output)
